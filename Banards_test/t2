import cma
import numpy as np
import matplotlib.pyplot as plt
from cmaes import CMA
from cma.fitness_functions import ff

iterations = 150
num_tests = 150

bounds = [-10, 10]

random_individuals = np.empty(num_tests,dtype=object)

abs_num_above = 0

abs_num_below = 0

def dummy_objective_function(x):
    return 0


xmin, xmax = -6, 10
ymin, ymax = -2, 12


options = {'maxiter': 50, 'verbose': -9, 'maxfevals': 1000, 'bounds': ([xmin, ymin], [xmax, ymax])}


for z in range(num_tests):
    start_points = [np.random.uniform(low=xmin, high=xmax),np.random.uniform(low=ymin, high=ymax)]
    optimizer = cma.CMAEvolutionStrategy(start_points, 8, options)
    for i in range(iterations):
        solutions = optimizer.ask()
        optimizer.tell(solutions, [dummy_objective_function(x) for x in solutions])
        optimizer.logger.add()  # write data to disc to be plotted
        optimizer.disp()
        if i == iterations - 1:
            random_individual = solutions[np.random.randint(len(solutions))]
            random_individuals[z] = random_individual


# print(random_individuals)
solutions = np.stack(random_individuals)



x = solutions[:, 0]
y = solutions[:, 1]
plt.scatter(x, y)

plt.xlim(xmin, xmax)
plt.ylim(ymin, ymax)


########################################

m = (ymax - ymin)/(xmax-xmin)
b = (ymax - (m*xmax))

x = np.linspace(xmin, xmax)
y = m * x + b
plt.plot(x, y, color="green")

# above = yes
above_counter = 0

# below = no
below_counter = 0

for point in random_individuals:

    x = point[0]
    y = point[1]

    if y > m * x + b:
        above_counter += 1
    elif y < m * x + b:
        below_counter += 1


print("above=", above_counter)
print("below=", below_counter)


# print("p-val?=", abs_num_above / abs_num_below)
# print("p-val?=", abs_num_below / abs_num_above)
plt.show()
